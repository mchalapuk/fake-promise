// Generated by CoffeeScript 2.3.1
(function() {
  var FakePromise, LoggingProxyHandler, RawFakePromise, sinon, stringifyArg;

  sinon = require("sinon");

  FakePromise = require("./FakePromise").default;

  describe("FakePromise", function() {
    var testedPromise;
    testedPromise = null;
    [null, void 0].forEach(function(arg) {
      return it(`calling static .reject(${arg}) throws`, function() {
        return should(function() {
          return FakePromise.reject(arg);
        }).throw(/error must not be undefined nor null.*/);
      });
    });
    describe("when constructed with Promise.reject(error)", function() {
      var expectedError;
      expectedError = new Error("test");
      beforeEach(function() {
        testedPromise = FakePromise.reject(expectedError);
        return void 0;
      });
      it("calling .setError(...) again throws an error", function() {
        return should(function() {
          return testedPromise.setError(expectedError);
        }).throw(/error already set.*/);
      });
      it("calling .reject(error) throws an error", function() {
        return should(function() {
          return testedPromise.reject(expectedError);
        }).throw(/error already set.*/);
      });
      it("calling .rejectOne(error) throws an error", function() {
        return should(function() {
          return testedPromise.rejectOne(expectedError);
        }).throw(/error already set.*/);
      });
      it("calling .reject() throws an error", function() {
        return should(function() {
          return testedPromise.reject();
        }).throw(/promise already rejected.*/);
      });
      it("calling .rejectOne() throws an error", function() {
        return should(function() {
          return testedPromise.rejectOne();
        }).throw(/promise already rejected.*/);
      });
      it("calling .setResult(...) throws an error", function() {
        return should(function() {
          return testedPromise.setResult({});
        }).throw(/trying to set result on a promise with error already set.*/);
      });
      it("calling .resolve() throws an error", function() {
        return should(function() {
          return testedPromise.resolve();
        }).throw(/trying to resolve a promise containing error.*/);
      });
      it("calling .resolveOne() throws an error", function() {
        return should(function() {
          return testedPromise.resolveOne();
        }).throw(/trying to resolve a promise containing error.*/);
      });
      it("resolves full promise chain", function() {
        return testedPromise.catch(function(err) {
          err.should.equal(expectedError);
          return err;
        }).then(function(err) {
          err.should.equal(expectedError);
          throw err;
        }).then(function(result) {
          throw new Error("expected rejection");
        }, function(err) {
          return err.should.equal(expectedError);
        });
      });
      return it("forwards the error to next promise in chain", function() {
        return testedPromise.then(function(result) {
          throw new Error(`expected rejection got result: ${result}`);
        }).then(function(result) {
          throw new Error(`expected rejection got result: ${result}`);
        }, function(err) {
          return err.should.equal(expectedError);
        });
      });
    });
    describe("when constructed with Promise.resolve(result)", function() {
      var expectedResult;
      expectedResult = {
        result: "test"
      };
      beforeEach(function() {
        testedPromise = FakePromise.resolve(expectedResult);
        return void 0;
      });
      it("calling .setError(...) again throws an error", function() {
        return should(function() {
          return testedPromise.setError(new Error("test"));
        }).throw(/trying to set error on a promise with result already set.*/);
      });
      it("calling .reject(error) throws an error", function() {
        return should(function() {
          return testedPromise.reject(new Error("test"));
        }).throw(/trying to reject a promise containing result.*/);
      });
      it("calling .rejectOne(error) throws an error", function() {
        return should(function() {
          return testedPromise.rejectOne(new Error("test"));
        }).throw(/trying to reject a promise containing result.*/);
      });
      it("calling .reject() throws an error", function() {
        return should(function() {
          return testedPromise.reject();
        }).throw(/trying to reject a promise containing result.*/);
      });
      it("calling .rejectOne() throws an error", function() {
        return should(function() {
          return testedPromise.rejectOne();
        }).throw(/trying to reject a promise containing result.*/);
      });
      it("calling .setResult(...) throws an error", function() {
        return should(function() {
          return testedPromise.setResult({});
        }).throw(/result already set.*/);
      });
      it("calling .resolve() throws an error", function() {
        return should(function() {
          return testedPromise.resolve();
        }).throw(/promise already resolved.*/);
      });
      it("calling .resolveOne() throws an error", function() {
        return should(function() {
          return testedPromise.resolveOne();
        }).throw(/promise already resolved.*/);
      });
      it("resolves full promise chain", function() {
        var error;
        error = new Error("error");
        return testedPromise.then(function(result) {
          result.should.equal(expectedResult);
          throw error;
        }).catch(function(err) {
          err.should.equal(error);
          return err;
        }).catch(function(result) {
          throw new Error(`expected rejection got result: ${result}`);
        }, function(err) {
          return err.should.equal(error);
        });
      });
      return it("forwards the result to next promise in chain", function() {
        return testedPromise.catch(function(err) {
          throw err;
        }).then(function(result) {
          return result.should.equal(expectedResult);
        });
      });
    });
    return describe("when instantiated with new", function() {
      beforeEach(function() {
        testedPromise = new FakePromise;
        return void 0;
      });
      ['setError', 'reject', 'rejectOne'].forEach(function(methodName) {
        return [null, void 0].forEach(function(arg) {
          return it(`calling .${methodName}(${arg}) throws`, function() {
            return should(function() {
              return testedPromise[methodName](arg);
            }).throw(/error must not be undefined nor null.*/);
          });
        });
      });
      describe("when after calling .resolve(result)", function() {
        var expectedResult;
        expectedResult = {};
        beforeEach(function() {
          return testedPromise.resolve(expectedResult);
        });
        return it("resolves full promise chain", function() {
          var error;
          error = new Error("test");
          return testedPromise.then(function(result) {
            result.should.equal(expectedResult);
            throw error;
          }).catch(function(err) {
            err.should.equal(error);
            return expectedResult;
          }).then(function(result) {
            (should(result)).equal(expectedResult);
            throw error;
          }).then(function(result) {
            throw new Error("expected rejection");
          }, function(err) {
            return err.should.equal(error);
          });
        });
      });
      describe("when after calling .reject(error)", function() {
        var expectedError;
        expectedError = new Error("test");
        beforeEach(function() {
          return testedPromise.reject(expectedError);
        });
        return it("resolves full promise chain", function() {
          return testedPromise.catch(function(err) {
            return err.should.equal(expectedError);
          }).then(function() {
            throw expectedError;
          }).then(function(result) {
            throw new Error("expected rejection");
          }, function(err) {
            return err.should.equal(expectedError);
          });
        });
      });
      describe("when after calling .resolve(resultPromise)", function() {
        var resultPromise;
        resultPromise = null;
        beforeEach(function() {
          resultPromise = new FakePromise;
          return testedPromise.resolve(resultPromise);
        });
        it("throws when calling .setResult", function() {
          return should(function() {
            return testedPromise.setResult({});
          }).throw(/result already set \(waiting for promise\).*/);
        });
        it("throws when calling .setError", function() {
          return should(function() {
            return testedPromise.setError({});
          }).throw(/result already set \(waiting for promise\).*/);
        });
        it("throws when calling .resolve", function() {
          return should(function() {
            return testedPromise.resolve({});
          }).throw(/result already set \(waiting for promise\).*/);
        });
        it("throws when calling .reject", function() {
          return should(function() {
            return testedPromise.reject({});
          }).throw(/result already set \(waiting for promise\).*/);
        });
        it("throws when calling .resolveOne", function() {
          return should(function() {
            return testedPromise.resolveOne({});
          }).throw(/result already set \(waiting for promise\).*/);
        });
        it("throws when calling .rejectOne", function() {
          return should(function() {
            return testedPromise.rejectOne({});
          }).throw(/result already set \(waiting for promise\).*/);
        });
        return describe("and after resolving resultPromise", function() {
          var expectedResult;
          expectedResult = {};
          beforeEach(function() {
            return resultPromise.resolve(expectedResult);
          });
          it("resolves the promise", function() {
            return testedPromise.then(function(result) {
              return result.should.equal(expectedResult);
            });
          });
          return describe("and after .then(returnAnotherPromise)", function() {
            var returnedPromise, testedPromise2;
            testedPromise2 = null;
            returnedPromise = null;
            beforeEach(function() {
              returnedPromise = new FakePromise;
              testedPromise2 = testedPromise.then(function() {
                return returnedPromise;
              });
              return void 0;
            });
            return describe("and after resoling returned promise", function() {
              var expectedResult2;
              expectedResult2 = {};
              beforeEach(function() {
                return returnedPromise.resolve(expectedResult2);
              });
              return it("resolves the promise chain", function() {
                return testedPromise2.then(function(result2) {
                  return result2.should.equal(expectedResult2);
                });
              });
            });
          });
        });
      });
      describe("when after calling .resolveOne(null)", function() {
        var nextPromise;
        nextPromise = null;
        beforeEach(function() {
          nextPromise = testedPromise.resolveOne(null);
          return void 0;
        });
        it("calling .then(callback) calls the callback immediately", function() {
          var callback;
          callback = sinon.spy();
          testedPromise.then(callback);
          return callback.should.have.callCount(1).and.have.been.calledWith(null);
        });
        it("calling .catch(callback) does nothing", function() {
          var callback;
          callback = sinon.spy();
          testedPromise.catch(callback);
          return callback.should.have.callCount(0);
        });
        return describe("and after calling .resolveOne(null).resolveOne()", function() {
          beforeEach(function() {
            nextPromise.resolveOne();
            return void 0;
          });
          return it("calling .then(passThrough).then(callback) calls the callback immediately", function() {
            var callback;
            callback = sinon.spy();
            testedPromise.then(function(arg) {
              return arg;
            }).then(callback);
            return callback.should.have.callCount(1).and.have.been.calledWith(null);
          });
        });
      });
      describe("when after .resolveOne() without result", function() {
        var nextPromise;
        nextPromise = null;
        beforeEach(function() {
          nextPromise = testedPromise.resolveOne();
          return void 0;
        });
        return describe("and after calling .setResult(result)", function() {
          var result;
          result = "result";
          beforeEach(function() {
            return testedPromise.setResult(result);
          });
          it("calling .then(callback) calls the callback immediately", function() {
            var callback;
            callback = sinon.spy();
            testedPromise.then(callback);
            return callback.should.have.callCount(1).and.have.been.calledWith(result);
          });
          return it("calling .catch(callback) does nothing", function() {
            var callback;
            callback = sinon.spy();
            testedPromise.catch(callback);
            return callback.should.have.callCount(0);
          });
        });
      });
      describe("when after .resolveOne() with resolved promise as result", function() {
        var nextPromise, result;
        nextPromise = null;
        result = "result";
        beforeEach(function() {
          var resultPromise;
          resultPromise = new FakePromise;
          resultPromise.resolveOne(result);
          nextPromise = testedPromise.resolveOne(resultPromise);
          return void 0;
        });
        it("calling .then(callback) calls the callback immediately", function() {
          var callback;
          callback = sinon.spy();
          testedPromise.then(callback);
          return callback.should.have.callCount(1).and.have.been.calledWith(result);
        });
        return it("calling .catch(callback) does nothing", function() {
          var callback;
          callback = sinon.spy();
          testedPromise.catch(callback);
          return callback.should.have.callCount(0);
        });
      });
      describe("when after .resolveOne() with rejected promise as result", function() {
        var error, nextPromise;
        nextPromise = null;
        error = new Error("rejected");
        beforeEach(function() {
          var resultPromise;
          resultPromise = new FakePromise;
          resultPromise.rejectOne(error);
          nextPromise = testedPromise.resolveOne(resultPromise);
          return void 0;
        });
        it("calling .catch(callback) calls the callback immediately", function() {
          var callback;
          callback = sinon.spy();
          testedPromise.catch(callback);
          return callback.should.have.callCount(1).and.have.been.calledWith(error);
        });
        return it("calling .then(callback) does nothing", function() {
          var callback;
          callback = sinon.spy();
          testedPromise.then(callback);
          return callback.should.have.callCount(0);
        });
      });
      describe("when after calling .rejectOne(error)", function() {
        var error, nextPromise;
        error = new Error("test");
        nextPromise = null;
        beforeEach(function() {
          nextPromise = testedPromise.rejectOne(error);
          return void 0;
        });
        it("calling .catch(callback) calls the callback immediately", function() {
          var callback;
          callback = sinon.spy();
          testedPromise.catch(callback);
          return callback.should.have.callCount(1).and.have.been.calledWith(error);
        });
        it("calling .then(callback) does nothing", function() {
          var callback;
          callback = sinon.spy();
          testedPromise.then(callback);
          return callback.should.have.callCount(0);
        });
        return describe("and after calling .catch(rethrow)", function() {
          nextPromise = null;
          beforeEach(function() {
            nextPromise = testedPromise.catch(function(me) {
              throw me;
            });
            return void 0;
          });
          return describe("and after calling .rejectOne(error).rejectOne()", function() {
            beforeEach(function() {
              nextPromise.rejectOne();
              return void 0;
            });
            return it("calling .catch(callback) calls the callback immediately", function() {
              var callback;
              callback = sinon.spy();
              nextPromise.catch(callback);
              return callback.should.have.callCount(1).and.have.been.calledWith(error);
            });
          });
        });
      });
      describe("when after .resolveOne(resultPromise)", function() {
        var nextPromise, resultPromise;
        resultPromise = null;
        nextPromise = null;
        beforeEach(function() {
          resultPromise = new FakePromise;
          nextPromise = testedPromise.resolveOne(resultPromise);
          return void 0;
        });
        it("calling .then(callback) does nothing", function() {
          var callback;
          callback = sinon.spy();
          testedPromise.then(callback);
          return callback.should.have.callCount(0);
        });
        it("calling .catch(callback) does nothing", function() {
          var callback;
          callback = sinon.spy();
          testedPromise.catch(callback);
          return callback.should.have.callCount(0);
        });
        describe("and after resolving resultPromise", function() {
          var result;
          result = {};
          beforeEach(function() {
            return resultPromise.resolve(result);
          });
          it("calling .then(callback) calls the callback immediately", function() {
            var callback;
            callback = sinon.spy();
            testedPromise.then(callback);
            return callback.should.have.callCount(1).and.have.been.calledWith(result);
          });
          return it("calling .catch(callback) does nothing", function() {
            var callback;
            callback = sinon.spy();
            testedPromise.catch(callback);
            return callback.should.have.callCount(0);
          });
        });
        return describe("and after rejecting resultPromise", function() {
          var error;
          error = new Error("rejected");
          beforeEach(function() {
            return resultPromise.reject(error);
          });
          it("calling .then(callback) does nothing", function() {
            var callback;
            callback = sinon.spy();
            testedPromise.then(callback);
            return callback.should.have.callCount(0);
          });
          return it("calling .catch(callback) calls the callback immediately", function() {
            var callback;
            callback = sinon.spy();
            testedPromise.catch(callback);
            return callback.should.have.callCount(1).and.have.been.calledWith(error);
          });
        });
      });
      describe("when after .then(onfulfilled) specified", function() {
        var nextPromise, thenCallback;
        thenCallback = null;
        nextPromise = null;
        beforeEach(function() {
          thenCallback = sinon.spy();
          nextPromise = testedPromise.then(thenCallback);
          return void 0;
        });
        it("throws calling .then(...) second time", function() {
          return should(function() {
            return testedPromise.then(thenCallback);
          }).throw(/promise already specified.*/);
        });
        it("throws calling .catch(...) on the same promise", function() {
          return should(function() {
            return testedPromise.catch(thenCallback);
          }).throw(/promise already specified.*/);
        });
        it(".setResult(undefined).resolveOne() doesn't throw", function() {
          testedPromise.setResult(void 0);
          testedPromise.resolveOne();
          return void 0;
        });
        describe("and after calling .resolveOne(arg)", function() {
          var arg;
          arg = "I will behave";
          beforeEach(function() {
            testedPromise.resolveOne(arg);
            return void 0;
          });
          it("calls proper callback", function() {
            return thenCallback.should.have.callCount(1);
          });
          return it("passes result to callback", function() {
            return thenCallback.should.have.been.calledWith(arg);
          });
        });
        return describe("and after .catch(onrejected) specified on returned promise", function() {
          var catchCallback;
          catchCallback = null;
          beforeEach(function() {
            catchCallback = sinon.spy();
            nextPromise.catch(catchCallback);
            return void 0;
          });
          return describe("and after calling .rejectOne(err).rejectOne()", function() {
            var err;
            err = new Error("I will never promise again");
            beforeEach(function() {
              testedPromise.rejectOne(err).rejectOne();
              return void 0;
            });
            it("calls proper callback", function() {
              return catchCallback.should.have.callCount(1);
            });
            return it("passes error to callback", function() {
              return catchCallback.should.have.been.calledWith(err);
            });
          });
        });
      });
      describe("when after .then(onfulfilled, onrejected) specified", function() {
        var catchCallback, thenCallback;
        thenCallback = null;
        catchCallback = null;
        beforeEach(function() {
          thenCallback = sinon.spy();
          catchCallback = sinon.spy();
          testedPromise.then(thenCallback, catchCallback);
          return void 0;
        });
        describe("and after calling .resolveOne(arg)", function() {
          var arg;
          arg = "I will clean my room";
          beforeEach(function() {
            testedPromise.resolveOne(arg);
            return void 0;
          });
          it("calls proper callback", function() {
            return thenCallback.should.have.callCount(1);
          });
          return it("passes result to callback", function() {
            return thenCallback.should.have.been.calledWith(arg);
          });
        });
        return describe("and after calling .rejectOne(err)", function() {
          var err;
          err = new Error("I will fulfill all promises");
          beforeEach(function() {
            testedPromise.rejectOne(err);
            return void 0;
          });
          it("calls proper callback", function() {
            return catchCallback.should.have.callCount(1);
          });
          return it("passes error to callback", function() {
            return catchCallback.should.have.been.calledWith(err);
          });
        });
      });
      describe("when after .then(passThrough).then(onfulfilled) specified", function() {
        var thenCallback;
        thenCallback = null;
        beforeEach(function() {
          thenCallback = sinon.spy();
          testedPromise.then(function(arg) {
            return arg;
          }).then(thenCallback);
          return void 0;
        });
        return describe("and after calling .resolveOne(arg).resolveOne()", function() {
          var arg;
          arg = "I will behave";
          beforeEach(function() {
            testedPromise.resolveOne(arg).resolveOne();
            return void 0;
          });
          it("calls proper callback", function() {
            return thenCallback.should.have.callCount(1);
          });
          return it("passes result to callback", function() {
            return thenCallback.should.have.been.calledWith(arg);
          });
        });
      });
      describe("when after .then(returnResolvedPromise).then(onfulfilled) specified", function() {
        var thenCallback;
        thenCallback = null;
        beforeEach(function() {
          var resultPromise;
          thenCallback = sinon.spy();
          resultPromise = new FakePromise;
          testedPromise.then(function(arg) {
            resultPromise.resolveOne(arg);
            return resultPromise;
          }).then(thenCallback);
          return void 0;
        });
        return describe("and after calling .resolveOne(arg).resolveOne()", function() {
          var arg;
          arg = "I will behave";
          beforeEach(function() {
            testedPromise.resolveOne(arg).resolveOne();
            return void 0;
          });
          it("calls proper callback", function() {
            return thenCallback.should.have.callCount(1);
          });
          return it("passes result to callback", function() {
            return thenCallback.should.have.been.calledWith(arg);
          });
        });
      });
      describe("when after .then(returnRejectedPromise).catch(onfulfilled) specified", function() {
        var catchCallback;
        catchCallback = null;
        beforeEach(function() {
          catchCallback = sinon.spy();
          testedPromise.then(function(arg) {
            var resultPromise;
            resultPromise = new FakePromise;
            resultPromise.rejectOne(arg);
            return resultPromise;
          }).catch(catchCallback);
          return void 0;
        });
        return describe("and after calling .resolveOne(arg).resolveOne()", function() {
          var arg;
          arg = "I will behave";
          beforeEach(function() {
            testedPromise.resolveOne(arg).rejectOne();
            return void 0;
          });
          it("calls proper callback", function() {
            return catchCallback.should.have.callCount(1);
          });
          return it("passes result to callback", function() {
            return catchCallback.should.have.been.calledWith(arg);
          });
        });
      });
      describe("when after .catch(rethrow).catch(onrejected) specified", function() {
        var catchCallback;
        catchCallback = null;
        beforeEach(function() {
          catchCallback = sinon.spy();
          testedPromise.catch(function(err) {
            throw err;
          }).catch(catchCallback);
          return void 0;
        });
        return describe("and after calling .rejectOne(arg).rejectOne()", function() {
          var err;
          err = new Error("This promise is a fake one");
          beforeEach(function() {
            testedPromise.rejectOne(err).rejectOne();
            return void 0;
          });
          it("calls proper callback", function() {
            return catchCallback.should.have.callCount(1);
          });
          return it("passes error to callback", function() {
            return catchCallback.should.have.been.calledWith(err);
          });
        });
      });
      describe("when after .catch(returnRejectedPromise).catch(onrejected) specified", function() {
        var catchCallback;
        catchCallback = null;
        beforeEach(function() {
          catchCallback = sinon.spy();
          testedPromise.catch(function(err) {
            var resultPromise;
            resultPromise = new FakePromise;
            resultPromise.rejectOne(err);
            return resultPromise;
          }).catch(catchCallback);
          return void 0;
        });
        return describe("and after calling .rejectOne(arg).rejectOne()", function() {
          var err;
          err = new Error("This promise is a fake one");
          beforeEach(function() {
            testedPromise.rejectOne(err).rejectOne();
            return void 0;
          });
          it("calls proper callback", function() {
            return catchCallback.should.have.callCount(1);
          });
          return it("passes error to callback", function() {
            return catchCallback.should.have.been.calledWith(err);
          });
        });
      });
      describe("when after .catch(returnResolvedPromise).then(onrejected) specified", function() {
        var thenCallback;
        thenCallback = null;
        beforeEach(function() {
          var resultPromise;
          thenCallback = sinon.spy();
          resultPromise = new FakePromise;
          testedPromise.catch(function(err) {
            resultPromise.resolveOne(err.message);
            return resultPromise;
          }).then(thenCallback);
          return void 0;
        });
        return describe("and after calling .rejectOne(arg).resolveOne()", function() {
          var err;
          err = "This promise is a fake one";
          beforeEach(function() {
            testedPromise.rejectOne(new Error(err)).resolveOne();
            return void 0;
          });
          it("calls proper callback", function() {
            return thenCallback.should.have.callCount(1);
          });
          return it("passes error to callback", function() {
            return thenCallback.should.have.been.calledWith(err);
          });
        });
      });
      describe("when after .setResult(result) called", function() {
        var expectedResult;
        expectedResult = {};
        beforeEach(function() {
          return testedPromise.setResult(expectedResult);
        });
        it("calling .setResult(...) again throws an error", function() {
          return should(function() {
            return testedPromise.setResult(expectedResult);
          }).throw(/result already set.*/);
        });
        it("calling .resolve(result) throws an error", function() {
          return should(function() {
            return testedPromise.resolve(expectedResult);
          }).throw(/result already set.*/);
        });
        it("calling .resolveOne(result) throws an error", function() {
          return should(function() {
            return testedPromise.resolveOne(expectedResult);
          }).throw(/result already set.*/);
        });
        it("calling .setError(...) throws an error", function() {
          return should(function() {
            return testedPromise.setError(new Error('test'));
          }).throw(/trying to set error on a promise with result already set.*/);
        });
        it("calling .reject() throws an error", function() {
          return should(function() {
            return testedPromise.reject();
          }).throw(/trying to reject a promise containing result.*/);
        });
        it("calling .rejectOne() throws an error", function() {
          return should(function() {
            return testedPromise.rejectOne();
          }).throw(/trying to reject a promise containing result.*/);
        });
        it("calling .resolve() does not throw", function() {
          testedPromise.resolve();
          return testedPromise.then(function(result) {
            return result.should.eql(expectedResult);
          });
        });
        return it("calling .resolveOne() does not throw", function() {
          testedPromise.resolveOne().resolveOne();
          return testedPromise.then(function(result) {
            return result.should.eql(expectedResult);
          });
        });
      });
      describe("when after .setResult(resolvedPromise) called", function() {
        var expectedResult;
        expectedResult = {};
        beforeEach(function() {
          var resultPromise;
          resultPromise = new FakePromise;
          resultPromise.resolve(expectedResult);
          return testedPromise.setResult(resultPromise);
        });
        it("calling .setResult(...) again throws an error", function() {
          return should(function() {
            return testedPromise.setResult(expectedResult);
          }).throw(/result already set.*/);
        });
        it("calling .resolve(result) throws an error", function() {
          return should(function() {
            return testedPromise.resolve(expectedResult);
          }).throw(/result already set.*/);
        });
        it("calling .resolveOne(result) throws an error", function() {
          return should(function() {
            return testedPromise.resolveOne(expectedResult);
          }).throw(/result already set.*/);
        });
        it("calling .setError(...) throws an error", function() {
          return should(function() {
            return testedPromise.setError(new Error('test'));
          }).throw(/trying to set error on a promise with result already set.*/);
        });
        it("calling .reject() throws an error", function() {
          return should(function() {
            return testedPromise.reject();
          }).throw(/trying to reject a promise containing result.*/);
        });
        it("calling .rejectOne() throws an error", function() {
          return should(function() {
            return testedPromise.rejectOne();
          }).throw(/trying to reject a promise containing result.*/);
        });
        it("calling .resolve() does not throw", function() {
          testedPromise.resolve();
          return testedPromise.then(function(result) {
            return result.should.eql(expectedResult);
          });
        });
        return it("calling .resolveOne() does not throw", function() {
          testedPromise.resolveOne().resolveOne();
          return testedPromise.then(function(result) {
            return result.should.eql(expectedResult);
          });
        });
      });
      describe("when after .setError(error) called", function() {
        var expectedError;
        expectedError = new Error("test");
        beforeEach(function() {
          return testedPromise.setError(expectedError);
        });
        it("calling .setError(...) again throws an error", function() {
          return should(function() {
            return testedPromise.setError(expectedError);
          }).throw(/error already set.*/);
        });
        it("calling .reject(error) throws an error", function() {
          return should(function() {
            return testedPromise.reject(expectedError);
          }).throw(/error already set.*/);
        });
        it("calling .rejectOne(error) throws an error", function() {
          return should(function() {
            return testedPromise.rejectOne(expectedError);
          }).throw(/error already set.*/);
        });
        it("calling .setError(...) throws an error", function() {
          return should(function() {
            return testedPromise.setResult({});
          }).throw(/trying to set result on a promise with error already set.*/);
        });
        it("calling .resolve() throws an error", function() {
          return should(function() {
            return testedPromise.resolve();
          }).throw(/trying to resolve a promise containing error.*/);
        });
        it("calling .resolveOne() throws an error", function() {
          return should(function() {
            return testedPromise.resolveOne();
          }).throw(/trying to resolve a promise containing error.*/);
        });
        it("calling .rejectOne() does not throw", function() {
          testedPromise.rejectOne().resolveOne();
          return testedPromise.then(function() {
            throw new Error("expected rejection");
          }, function(error) {
            return error.should.eql(expectedError);
          });
        });
        return it("calling .reject() does not throw", function() {
          testedPromise.reject();
          return testedPromise.then(function() {
            throw new Error("expected rejection");
          }, function(error) {
            return error.should.eql(expectedError);
          });
        });
      });
      describe("when after .setResult(rejectedPromise) called", function() {
        var expectedError;
        expectedError = new Error("test");
        beforeEach(function() {
          var resultPromise;
          resultPromise = new FakePromise;
          resultPromise.reject(expectedError);
          return testedPromise.setResult(resultPromise);
        });
        it("calling .setError(...) again throws an error", function() {
          return should(function() {
            return testedPromise.setError(expectedError);
          }).throw(/error already set.*/);
        });
        it("calling .reject(error) throws an error", function() {
          return should(function() {
            return testedPromise.reject(expectedError);
          }).throw(/error already set.*/);
        });
        it("calling .rejectOne(error) throws an error", function() {
          return should(function() {
            return testedPromise.rejectOne(expectedError);
          }).throw(/error already set.*/);
        });
        it("calling .setError(...) throws an error", function() {
          return should(function() {
            return testedPromise.setResult({});
          }).throw(/trying to set result on a promise with error already set.*/);
        });
        it("calling .resolve() throws an error", function() {
          return should(function() {
            return testedPromise.resolve();
          }).throw(/trying to resolve a promise containing error.*/);
        });
        it("calling .resolveOne() throws an error", function() {
          return should(function() {
            return testedPromise.resolveOne();
          }).throw(/trying to resolve a promise containing error.*/);
        });
        it("calling .reject() does not throw", function() {
          testedPromise.reject();
          return testedPromise.then(function() {
            throw new Error("expected rejection");
          }, function(error) {
            return error.should.eql(expectedError);
          });
        });
        return it("calling .rejectOne() does not throw", function() {
          testedPromise.rejectOne().resolveOne();
          return testedPromise.then(function() {
            throw new Error("expected rejection");
          }, function(error) {
            return error.should.eql(expectedError);
          });
        });
      });
      describe("when after calling .setResult(undefined)", function() {
        var expectedResult;
        expectedResult = void 0;
        beforeEach(function() {
          return testedPromise.setResult(expectedResult);
        });
        it("calling .resolveOne() and .then() resolves the promise", function() {
          testedPromise.resolveOne().resolveOne();
          return testedPromise.then(function(result) {
            return (should(result)).equal(expectedResult);
          });
        });
        return it("calling .resolve() and .then() resolves the promise", function() {
          testedPromise.resolve();
          return testedPromise.then(function(result) {
            return (should(result)).equal(expectedResult);
          });
        });
      });
      return describe("when without calling .setResult()", function() {
        var expectedResult;
        expectedResult = void 0;
        it("calling .resolveOne() and .then() resolves the promise", function() {
          testedPromise.resolveOne().resolveOne();
          return testedPromise.then(function(result) {
            return (should(result)).equal(expectedResult);
          });
        });
        return it("calling .resolve() and .then() resolves the promise", function() {
          testedPromise.resolve();
          return testedPromise.then(function(result) {
            return (should(result)).equal(expectedResult);
          });
        });
      });
    });
  });

  LoggingProxyHandler = class LoggingProxyHandler {
    constructor() {
      this.indent = 0;
    }

    construct(Target, args) {
      var e, instance, proxy;
      this.log(Target, "construct".yellow, `${Target.name}(${(args.map(stringifyArg)).join(", ")})`);
      this.indent += 1;
      try {
        instance = new Target;
        proxy = new Proxy(instance, this);
      } catch (error1) {
        e = error1;
        this.log(Target, "throw".red, stringifyArg(e));
        this.indent -= 1;
        throw e;
      }
      this.log(Target, "return".green, stringifyArg(instance));
      this.indent -= 1;
      return proxy;
    }

    apply(target, thisArg, args) {
      var e, result;
      this.log(target, "call".yellow, `${target.name}(${(args.map(stringifyArg)).join(", ")})`);
      this.indent += 1;
      try {
        result = target.apply(thisArg, args);
      } catch (error1) {
        e = error1;
        this.log(target, "throw".red, stringifyArg(e));
        this.indent -= 1;
        throw e;
      }
      this.log(target, "return".green, stringifyArg(result));
      this.indent -= 1;
      return result;
    }

    get(target, property, receiver) {
      var e, value;
      try {
        value = target[property];
        if (property === "id" || property === "nextPromise") {
          return value;
        }
        this.log(target, "get".blue, `${property} -> ${stringifyArg(value)}`);
        if (typeof value === "function") {
          value.id = target.id;
          return new Proxy(value, this);
        } else {
          return value;
        }
      } catch (error1) {
        e = error1;
        this.log(target, "get".red, `${property} -> throw ${stringifyArg(e)}`);
        throw e;
      }
    }

    set(target, property, value, receiver) {
      var e, previous;
      try {
        previous = target[property];
        this.log(target, "set".magenta, `${property} = ${stringifyArg(value)}`);
        if (property === "nextPromise") {
          value = new Proxy(value, this);
        }
        target[property] = value;
        return true;
      } catch (error1) {
        e = error1;
        this.log(target, "set".red, `${property} = ${stringify(value)} -> throw ${stringifyArg(e)}`);
        throw e;
      }
    }

    log(target, operation, args) {
      return console.log(`${this.printIndent()}${(target.id ? `#${target.id} `.gray : "")}${operation} ${(args ? args.gray : "")}`);
    }

    printIndent() {
      return "                                                             ".substring(0, this.indent * 2);
    }

  };

  RawFakePromise = FakePromise;

  stringifyArg = function(arg) {
    if (arg instanceof RawFakePromise) {
      return `FakePromise#${arg.id}`;
    } else if (arg instanceof Error) {
      return `${arg.name}(${JSON.stringify(arg.message)})`;
    } else if (typeof arg === "function") {
      return `function ${arg.name || "unnamed"}`;
    } else {
      return JSON.stringify(arg);
    }
  };

  if (process.env.hasOwnProperty("DEBUG")) {
    // enable crazy debug logs
    FakePromise = new Proxy(RawFakePromise, new LoggingProxyHandler(RawFakePromise));
  }

}).call(this);

//# sourceMappingURL=FakePromise.spec.js.map
