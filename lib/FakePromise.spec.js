// Generated by CoffeeScript 1.12.7
(function() {
  var FakePromise, FunctionProxyHandler, LoggingProxyHandler, OriginalFakePromise, indent, printIndent, sinon, stringifyArg;

  sinon = require("sinon");

  FakePromise = require("./FakePromise")["default"];

  if (process.env.hasOwnProperty("DEBUG")) {
    OriginalFakePromise = FakePromise;
    FakePromise = function() {
      var instance;
      instance = new OriginalFakePromise;
      return new Proxy(instance, new LoggingProxyHandler(instance));
    };
  }

  describe("FakePromise", function() {
    var testedPromise;
    testedPromise = null;
    beforeEach(function() {
      testedPromise = new FakePromise;
      return void 0;
    });
    it("calling .setError(undefined) throws", function() {
      return should(function() {
        return testedPromise.setError(void 0);
      })["throw"]("error must not be undefined nor null");
    });
    it("calling .setError(null) throws", function() {
      return should(function() {
        return testedPromise.setError(null);
      })["throw"]("error must not be undefined nor null");
    });
    describe("when after calling .resolve(null)", function() {
      var nextPromise;
      nextPromise = null;
      beforeEach(function() {
        nextPromise = testedPromise.resolve(null);
        return void 0;
      });
      it("calling .then(callback) calls the callback immediately", function() {
        var callback;
        callback = sinon.spy();
        testedPromise.then(callback);
        return callback.should.have.callCount(1).and.have.been.calledWith(null);
      });
      it("calling .catch(callback) does nothing", function() {
        var callback;
        callback = sinon.spy();
        testedPromise["catch"](callback);
        return callback.should.have.callCount(0);
      });
      return describe("and after calling .resolve(null).resolve()", function() {
        beforeEach(function() {
          nextPromise.resolve();
          return void 0;
        });
        return it("calling .then(passThrough).then(callback) calls the callback immediately", function() {
          var callback;
          callback = sinon.spy();
          testedPromise.then(function(arg) {
            return arg;
          }).then(callback);
          return callback.should.have.callCount(1).and.have.been.calledWith(null);
        });
      });
    });
    describe("when after .resolve() without result", function() {
      var nextPromise;
      nextPromise = null;
      beforeEach(function() {
        nextPromise = testedPromise.resolve();
        return void 0;
      });
      return describe("and after calling .setResult(result)", function() {
        var result;
        result = "result";
        beforeEach(function() {
          return testedPromise.setResult(result);
        });
        it("calling .then(callback) calls the callback immediately", function() {
          var callback;
          callback = sinon.spy();
          testedPromise.then(callback);
          return callback.should.have.callCount(1).and.have.been.calledWith(result);
        });
        return it("calling .catch(callback) does nothing", function() {
          var callback;
          callback = sinon.spy();
          testedPromise["catch"](callback);
          return callback.should.have.callCount(0);
        });
      });
    });
    describe("when after .resolve() with resolved promise as result", function() {
      var nextPromise, result;
      nextPromise = null;
      result = "result";
      beforeEach(function() {
        var resultPromise;
        resultPromise = new FakePromise;
        resultPromise.resolve(result);
        nextPromise = testedPromise.resolve(resultPromise);
        return void 0;
      });
      it("calling .then(callback) calls the callback immediately", function() {
        var callback;
        callback = sinon.spy();
        testedPromise.then(callback);
        return callback.should.have.callCount(1).and.have.been.calledWith(result);
      });
      return it("calling .catch(callback) does nothing", function() {
        var callback;
        callback = sinon.spy();
        testedPromise["catch"](callback);
        return callback.should.have.callCount(0);
      });
    });
    describe("when after .resolve() with rejected promise as result", function() {
      var error, nextPromise;
      nextPromise = null;
      error = new Error("rejected");
      beforeEach(function() {
        var resultPromise;
        resultPromise = new FakePromise;
        resultPromise.reject(error);
        nextPromise = testedPromise.resolve(resultPromise);
        return void 0;
      });
      it("calling .catch(callback) calls the callback immediately", function() {
        var callback;
        callback = sinon.spy();
        testedPromise["catch"](callback);
        return callback.should.have.callCount(1).and.have.been.calledWith(error);
      });
      return it("calling .then(callback) does nothing", function() {
        var callback;
        callback = sinon.spy();
        testedPromise.then(callback);
        return callback.should.have.callCount(0);
      });
    });
    describe("when after calling .reject(error)", function() {
      var error, nextPromise;
      error = new Error("test");
      nextPromise = null;
      beforeEach(function() {
        nextPromise = testedPromise.reject(error);
        return void 0;
      });
      it("calling .catch(callback) calls the callback immediately", function() {
        var callback;
        callback = sinon.spy();
        testedPromise["catch"](callback);
        return callback.should.have.callCount(1).and.have.been.calledWith(error);
      });
      it("calling .then(callback) does nothing", function() {
        var callback;
        callback = sinon.spy();
        testedPromise.then(callback);
        return callback.should.have.callCount(0);
      });
      return describe("and after calling .reject(error).reject()", function() {
        beforeEach(function() {
          nextPromise.reject();
          return void 0;
        });
        return it("calling .catch(rethrow).catch(callback) calls the callback immediately", function() {
          var callback;
          callback = sinon.spy();
          testedPromise["catch"](function(me) {
            throw me;
          })["catch"](callback);
          return callback.should.have.callCount(1).and.have.been.calledWith(error);
        });
      });
    });
    describe("when after .then(onfulfilled) specified", function() {
      var nextPromise, thenCallback;
      thenCallback = null;
      nextPromise = null;
      beforeEach(function() {
        thenCallback = sinon.spy();
        nextPromise = testedPromise.then(thenCallback);
        return void 0;
      });
      it("throws calling .then(...) second time", function() {
        return should(function() {
          return testedPromise.then(thenCallback);
        })["throw"](new Error("promise already specified"));
      });
      it("throws calling .catch(...) on the same promise", function() {
        return should(function() {
          return testedPromise["catch"](thenCallback);
        })["throw"](new Error("promise already specified"));
      });
      it(".setResult(undefined).resolve() doesn't throw", function() {
        testedPromise.setResult(void 0);
        testedPromise.resolve();
        return void 0;
      });
      describe("and after calling .resolve(arg)", function() {
        var arg;
        arg = "I will behave";
        beforeEach(function() {
          testedPromise.resolve(arg);
          return void 0;
        });
        it("calls proper callback", function() {
          return thenCallback.should.have.callCount(1);
        });
        return it("passes result to callback", function() {
          return thenCallback.should.have.been.calledWith(arg);
        });
      });
      return describe("and after .catch(onrejected) specified on returned promise", function() {
        var catchCallback;
        catchCallback = null;
        beforeEach(function() {
          catchCallback = sinon.spy();
          nextPromise["catch"](catchCallback);
          return void 0;
        });
        return describe("and after calling .reject(err).reject()", function() {
          var err;
          err = new Error("I will never promise again");
          beforeEach(function() {
            testedPromise.reject(err).reject();
            return void 0;
          });
          it("calls proper callback", function() {
            return catchCallback.should.have.callCount(1);
          });
          return it("passes error to callback", function() {
            return catchCallback.should.have.been.calledWith(err);
          });
        });
      });
    });
    describe("when after .then(onfulfilled, onrejected) specified", function() {
      var catchCallback, thenCallback;
      thenCallback = null;
      catchCallback = null;
      beforeEach(function() {
        thenCallback = sinon.spy();
        catchCallback = sinon.spy();
        testedPromise.then(thenCallback, catchCallback);
        return void 0;
      });
      describe("and after calling .resolve(arg)", function() {
        var arg;
        arg = "I will clean my room";
        beforeEach(function() {
          testedPromise.resolve(arg);
          return void 0;
        });
        it("calls proper callback", function() {
          return thenCallback.should.have.callCount(1);
        });
        return it("passes result to callback", function() {
          return thenCallback.should.have.been.calledWith(arg);
        });
      });
      return describe("and after calling .reject(err)", function() {
        var err;
        err = new Error("I will fulfill all promises");
        beforeEach(function() {
          testedPromise.reject(err);
          return void 0;
        });
        it("calls proper callback", function() {
          return catchCallback.should.have.callCount(1);
        });
        return it("passes error to callback", function() {
          return catchCallback.should.have.been.calledWith(err);
        });
      });
    });
    describe("when after .then(passThrough).then(onfulfilled) specified", function() {
      var thenCallback;
      thenCallback = null;
      beforeEach(function() {
        thenCallback = sinon.spy();
        testedPromise.then(function(arg) {
          return arg;
        }).then(thenCallback);
        return void 0;
      });
      return describe("and after calling .resolve(arg).resolve()", function() {
        var arg;
        arg = "I will behave";
        beforeEach(function() {
          testedPromise.resolve(arg).resolve();
          return void 0;
        });
        it("calls proper callback", function() {
          return thenCallback.should.have.callCount(1);
        });
        return it("passes result to callback", function() {
          return thenCallback.should.have.been.calledWith(arg);
        });
      });
    });
    describe("when after .then(returnResolvedPromise).then(onfulfilled) specified", function() {
      var thenCallback;
      thenCallback = null;
      beforeEach(function() {
        var resultPromise;
        thenCallback = sinon.spy();
        resultPromise = new FakePromise;
        testedPromise.then(function(arg) {
          resultPromise.resolve(arg);
          return resultPromise;
        }).then(thenCallback);
        return void 0;
      });
      return describe("and after calling .resolve(arg).resolve()", function() {
        var arg;
        arg = "I will behave";
        beforeEach(function() {
          testedPromise.resolve(arg).resolve();
          return void 0;
        });
        it("calls proper callback", function() {
          return thenCallback.should.have.callCount(1);
        });
        return it("passes result to callback", function() {
          return thenCallback.should.have.been.calledWith(arg);
        });
      });
    });
    describe("when after .then(returnRejectedPromise).catch(onfulfilled) specified", function() {
      var catchCallback;
      catchCallback = null;
      beforeEach(function() {
        catchCallback = sinon.spy();
        testedPromise.then(function(arg) {
          var resultPromise;
          resultPromise = new FakePromise;
          resultPromise.reject(arg);
          return resultPromise;
        })["catch"](catchCallback);
        return void 0;
      });
      return describe("and after calling .resolve(arg).resolve()", function() {
        var arg;
        arg = "I will behave";
        beforeEach(function() {
          testedPromise.resolve(arg).reject();
          return void 0;
        });
        it("calls proper callback", function() {
          return catchCallback.should.have.callCount(1);
        });
        return it("passes result to callback", function() {
          return catchCallback.should.have.been.calledWith(arg);
        });
      });
    });
    describe("when after .catch(rethrow).catch(onrejected) specified", function() {
      var catchCallback;
      catchCallback = null;
      beforeEach(function() {
        catchCallback = sinon.spy();
        testedPromise["catch"](function(err) {
          throw err;
        })["catch"](catchCallback);
        return void 0;
      });
      return describe("and after calling .reject(arg).reject()", function() {
        var err;
        err = new Error("This promise is a fake one");
        beforeEach(function() {
          testedPromise.reject(err).reject();
          return void 0;
        });
        it("calls proper callback", function() {
          return catchCallback.should.have.callCount(1);
        });
        return it("passes error to callback", function() {
          return catchCallback.should.have.been.calledWith(err);
        });
      });
    });
    describe("when after .catch(returnRejectedPromise).catch(onrejected) specified", function() {
      var catchCallback;
      catchCallback = null;
      beforeEach(function() {
        catchCallback = sinon.spy();
        testedPromise["catch"](function(err) {
          var resultPromise;
          resultPromise = new FakePromise;
          resultPromise.reject(err);
          return resultPromise;
        })["catch"](catchCallback);
        return void 0;
      });
      return describe("and after calling .reject(arg).reject()", function() {
        var err;
        err = new Error("This promise is a fake one");
        beforeEach(function() {
          testedPromise.reject(err).reject();
          return void 0;
        });
        it("calls proper callback", function() {
          return catchCallback.should.have.callCount(1);
        });
        return it("passes error to callback", function() {
          return catchCallback.should.have.been.calledWith(err);
        });
      });
    });
    describe("when after .catch(returnResolvedPromise).then(onrejected) specified", function() {
      var thenCallback;
      thenCallback = null;
      beforeEach(function() {
        var resultPromise;
        thenCallback = sinon.spy();
        resultPromise = new FakePromise;
        testedPromise["catch"](function(err) {
          resultPromise.resolve(err.message);
          return resultPromise;
        }).then(thenCallback);
        return void 0;
      });
      return describe("and after calling .reject(arg).resolve()", function() {
        var err;
        err = "This promise is a fake one";
        beforeEach(function() {
          testedPromise.reject(new Error(err)).resolve();
          return void 0;
        });
        it("calls proper callback", function() {
          return thenCallback.should.have.callCount(1);
        });
        return it("passes error to callback", function() {
          return thenCallback.should.have.been.calledWith(err);
        });
      });
    });
    describe("when after .setResult(result) called", function() {
      var expectedResult;
      expectedResult = {};
      beforeEach(function() {
        return testedPromise.setResult(expectedResult);
      });
      it("calling .setResult(...) again throws an error", function() {
        return should(function() {
          return testedPromise.setResult(expectedResult);
        })["throw"]("result already set");
      });
      it("calling .resolve(result) throws an error", function() {
        return should(function() {
          return testedPromise.resolve(expectedResult);
        })["throw"]("result already set");
      });
      it("calling .setError(...) throws an error", function() {
        return should(function() {
          return testedPromise.setError(new Error('test'));
        })["throw"]("trying to set error on a promise with result already set");
      });
      it("calling .reject() throws an error", function() {
        return should(function() {
          return testedPromise.reject();
        })["throw"]("trying to reject a promise containing result");
      });
      return it("calling .resolve() does not throw", function() {
        testedPromise.resolve().resolve();
        return testedPromise.then(function(result) {
          return result.should.eql(expectedResult);
        });
      });
    });
    describe("when after .setResult(resolvedPromise) called", function() {
      var expectedResult;
      expectedResult = {};
      beforeEach(function() {
        var resultPromise;
        resultPromise = new FakePromise;
        resultPromise.resolve(expectedResult);
        return testedPromise.setResult(resultPromise);
      });
      it("calling .setResult(...) again throws an error", function() {
        return should(function() {
          return testedPromise.setResult(expectedResult);
        })["throw"]("result already set");
      });
      it("calling .resolve(result) throws an error", function() {
        return should(function() {
          return testedPromise.resolve(expectedResult);
        })["throw"]("result already set");
      });
      it("calling .setError(...) throws an error", function() {
        return should(function() {
          return testedPromise.setError(new Error('test'));
        })["throw"]("trying to set error on a promise with result already set");
      });
      it("calling .reject() throws an error", function() {
        return should(function() {
          return testedPromise.reject();
        })["throw"]("trying to reject a promise containing result");
      });
      return it("calling .resolve() does not throw", function() {
        testedPromise.resolve().resolve();
        return testedPromise.then(function(result) {
          return result.should.eql(expectedResult);
        });
      });
    });
    describe("when after .setError(error) called", function() {
      var expectedError;
      expectedError = new Error("test");
      beforeEach(function() {
        return testedPromise.setError(expectedError);
      });
      it("calling .setError(...) again throws an error", function() {
        return should(function() {
          return testedPromise.setError(expectedError);
        })["throw"]("error already set");
      });
      it("calling .reject(error) throws an error", function() {
        return should(function() {
          return testedPromise.reject(expectedError);
        })["throw"]("error already set");
      });
      it("calling .setError(...) throws an error", function() {
        return should(function() {
          return testedPromise.setResult({});
        })["throw"]("trying to set result on a promise with error already set");
      });
      it("calling .resolve() throws an error", function() {
        return should(function() {
          return testedPromise.resolve();
        })["throw"]("trying to resolve a promise containing error");
      });
      return it("calling .reject() does not throw", function() {
        testedPromise.reject().resolve();
        return testedPromise.then(function() {
          throw new Error("expected rejection");
        }, function(error) {
          return error.should.eql(expectedError);
        });
      });
    });
    describe("when after .setResult(rejectedPromise) called", function() {
      var expectedError;
      expectedError = new Error("test");
      beforeEach(function() {
        var resultPromise;
        resultPromise = new FakePromise;
        resultPromise.reject(expectedError);
        return testedPromise.setResult(resultPromise);
      });
      it("calling .setError(...) again throws an error", function() {
        return should(function() {
          return testedPromise.setError(expectedError);
        })["throw"]("error already set");
      });
      it("calling .reject(error) throws an error", function() {
        return should(function() {
          return testedPromise.reject(expectedError);
        })["throw"]("error already set");
      });
      it("calling .setError(...) throws an error", function() {
        return should(function() {
          return testedPromise.setResult({});
        })["throw"]("trying to set result on a promise with error already set");
      });
      it("calling .resolve() throws an error", function() {
        return should(function() {
          return testedPromise.resolve();
        })["throw"]("trying to resolve a promise containing error");
      });
      return it("calling .reject() does not throw", function() {
        testedPromise.reject().resolve();
        return testedPromise.then(function() {
          throw new Error("expected rejection");
        }, function(error) {
          return error.should.eql(expectedError);
        });
      });
    });
    return describe("when after calling .setResult(undefined)", function() {
      var expectedResult;
      expectedResult = void 0;
      beforeEach(function() {
        return testedPromise.setResult(expectedResult);
      });
      return it("calling .resolve() does not throw", function() {
        testedPromise.resolve().resolve();
        return testedPromise.then(function(result) {
          return (should(result)).equal(expectedResult);
        });
      });
    });
  });

  indent = 0;

  FunctionProxyHandler = (function() {
    function FunctionProxyHandler(name, parent) {
      this.name = name;
      this.parent = parent;
    }

    FunctionProxyHandler.prototype.apply = function(target, thisArg, argumentList) {
      var e, result;
      this.parent.log("call".yellow, this.name + "(" + ((argumentList.map(stringifyArg)).join(", ")) + ")");
      indent += 1;
      try {
        result = target.apply(thisArg, argumentList);
      } catch (error1) {
        e = error1;
        this.parent.log("throw".red, stringifyArg(e));
        indent -= 1;
        throw e;
      }
      this.parent.log("return".green, stringifyArg(result));
      indent -= 1;
      return result;
    };

    return FunctionProxyHandler;

  })();

  LoggingProxyHandler = (function() {
    function LoggingProxyHandler(target1) {
      this.target = target1;
      this.indent = 0;
    }

    LoggingProxyHandler.prototype.get = function(target, property, receiver) {
      var value;
      value = target[property];
      if (property === "id" || property === "nextPromise") {
        return value;
      }
      this.log("get".blue, property + " -> " + (stringifyArg(value)));
      if (typeof value === "function") {
        return new Proxy(value, new FunctionProxyHandler(property, this));
      } else {
        return value;
      }
    };

    LoggingProxyHandler.prototype.set = function(target, property, value, receiver) {
      var previous;
      previous = target[property];
      this.log("set".magenta, property + " = " + (stringifyArg(value)));
      if (property === "nextPromise") {
        value = new Proxy(value, new LoggingProxyHandler(value));
      }
      target[property] = value;
      return true;
    };

    LoggingProxyHandler.prototype.log = function(operation, args) {
      return console.log("" + (printIndent()) + ("#" + this.target.id).gray + " " + operation + " " + (args ? args.gray : ""));
    };

    return LoggingProxyHandler;

  })();

  printIndent = function() {
    return "                                                             ".substring(0, indent * 2);
  };

  stringifyArg = function(arg) {
    if (arg instanceof OriginalFakePromise) {
      return "FakePromise#" + arg.id;
    } else if (arg instanceof Error) {
      return arg.name + "(" + (JSON.stringify(arg.message)) + ")";
    } else if (typeof arg === "function") {
      return "function " + (arg.name || "unnamed");
    } else {
      return JSON.stringify(arg);
    }
  };

}).call(this);

//# sourceMappingURL=FakePromise.spec.js.map
